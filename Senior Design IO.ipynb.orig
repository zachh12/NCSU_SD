{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import time\n",
    "import serial"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [],
   "source": [
    "ser = serial.Serial('/dev/cu.usbmodem14201', 9600)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [],
   "source": [
    "file1 = open(r'/Users/Elizabeth/Desktop/sourcepositions.txt', 'w+')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Input horizontal distance from center of detector to end of region you want to scan (in cm)3\n",
      "Input vertical distance from center of detector to end of region you want to scan (in cm)3\n"
     ]
    }
   ],
   "source": [
    "Length = float(input(\"Input horizontal distance from center of detector to end of region you want to scan (in cm)\"))\n",
    "Height = float(input(\"Input vertical distance from center of detector to end of region you want to scan (in cm)\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 1 rev = dist traveled is pitch of threaded rod\n",
    "\n",
    "pitch = .8 # distance between threads in metric units (cm)\n",
    "step_ang = 1.8 # degrees\n",
    "steps_per_rev_x = 400 # number of steps to travel the distance equivalent to pitch\n",
    "steps_per_rev_y = 200 # number of steps to travel the distance equivalent to pitch\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {},
   "outputs": [],
   "source": [
    "# position collimator to starting position in top left corner --> collimator starts in center of region before specifying a starting point\n",
    "\n",
    "start_x = Length\n",
    "start_y = Height"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {},
   "outputs": [],
   "source": [
    "# steps to take to travel dist to starting position\n",
    "\n",
    "start_stepsx = (start_x/pitch) * steps_per_rev_x\n",
    "start_stepsy = (start_y/pitch) * steps_per_rev_y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {},
   "outputs": [],
   "source": [
    "inputx=('x,' + str(start_stepsx) + ',1')\n",
    "inputy=('y,' + str(start_stepsy) + ',1')\n",
    "\n",
    "#inputx = bytes(inputx, 'utf-8')\n",
    "#inputy = bytes(inputy, 'utf-8')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "9"
      ]
     },
     "execution_count": 76,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ser.write(str.encode(inputx))\n",
    "time.sleep(5)\n",
    "ser.write(str.encode(inputy))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Input the granularity (distance between the center of scanned spots in cm)1\n"
     ]
    }
   ],
   "source": [
    "# granularity - distance between center of scanned spots (in cm)\n",
    "gran = float(input(\"Input the granularity (distance between the center of scanned spots in cm)\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "x\n",
      "x\n",
      "x\n",
      "x\n",
      "x\n"
     ]
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-79-706a8bcfa99c>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     15\u001b[0m         \u001b[0minputmovex\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m'x,'\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmove_x\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m',0'\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     16\u001b[0m         \u001b[0mser\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mwrite\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstr\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mencode\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minputmovex\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 17\u001b[0;31m         \u001b[0mtime\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msleep\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m5\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     18\u001b[0m         \u001b[0mx_pos\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0mgran\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     19\u001b[0m         \u001b[0mfile1\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mwrite\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'position'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "x_travel_dist = 2 * Length\n",
    "y_travel_dist = 2 * Height\n",
    "\n",
    "x_dist = 0\n",
    "y_dist = y_travel_dist\n",
    "\n",
    "x_pos = 0\n",
    "y_pos = 0\n",
    "\n",
    "while y_dist >= 0:\n",
    "    if x_dist <= (x_travel_dist + gran):\n",
    "        #move over right to next region to be scanned\n",
    "        move_x = (gran/pitch) * steps_per_rev_x #num of steps to take to move to next scanned region\n",
    "        x_dist += gran\n",
    "        inputmovex = 'x,' + str(move_x) + ',0'\n",
    "        ser.write(str.encode(inputmovex))\n",
    "        time.sleep(5)\n",
    "        x_pos += gran\n",
    "        file1.write(\"%i %5.2f\\n\" % (x_pos , y_pos))\n",
    "        print('x')\n",
    "    else:\n",
    "        if y_dist > 0:\n",
    "            #move down a row\n",
    "            move_y = (gran/pitch) * steps_per_rev_y\n",
    "            y_dist -= gran\n",
    "            y_pos += gran\n",
    "            x_dist = 0\n",
    "            x_pos = 0\n",
    "            inputmovey = 'y,' + str(move_y) + ',0'\n",
    "            ser.write(str.encode(inputmovey))\n",
    "            time.sleep(5)\n",
    "            print('y')\n",
    "\n",
    "            #move back to starting x position on left side\n",
    "            move_x = (x_travel_dist/pitch) * steps_per_rev_x\n",
    "            inputmovex = 'x,' + str(move_x) + ',1'\n",
    "            ser.write(str.encode(inputmovex))\n",
    "            file1.write(\"%i %5.2f\\n\" % (x_pos , y_pos))\n",
    "            print('xreset')\n",
    "        else:\n",
    "            print(\"scan complete\")\n",
    "            break\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "10"
      ]
     },
     "execution_count": 43,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# reset to middle\n",
    "\n",
    "inputx=('x,' + str(start_stepsx) + ',1')\n",
    "inputy=('y,' + str(start_stepsy) + ',1')\n",
    "\n",
    "ser.write(str.encode(inputx))\n",
    "time.sleep(5)\n",
    "ser.write(str.encode(inputy))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x_travel_dist = 2 * Length\n",
    "y_travel_dist = 2 * Height\n",
    "\n",
    "x_dist = 0\n",
    "y_dist = y_travel_dist\n",
    "plt.plot(x_dist, y_dist, 'r.')\n",
    "\n",
    "while y_dist >= 0:\n",
    "    if x_dist <= (x_travel_dist + gran):\n",
    "        #move over right to next region to be scanned\n",
    "        move_x = (gran/pitch) * steps_per_rev #num of steps to take to move to next scanned region\n",
    "        x_dist += gran\n",
    "        plt.plot(x_dist, y_dist, 'r.')\n",
    "    else:\n",
    "        if y_dist > 0:\n",
    "            #move down a row\n",
    "            move_y = (gran/pitch) * steps_per_rev\n",
    "            y_dist -= gran\n",
    "            x_dist = 0\n",
    "            plt.plot(x_dist, y_dist, 'r.')\n",
    "\n",
    "            #move back to starting x position on left side\n",
    "            move_x = (x_travel_dist/pitch) * steps_per_rev\n",
    "        else:\n",
    "            print(\"scan complete\")\n",
    "            break\n",
    "        \n",
    "plt.title('Region Scanned and the Points Where Source Position is Recorded')    \n",
    "plt.xlabel('x position (cm)')\n",
    "plt.ylabel('y position (cm)')\n",
    "plt.savefig('Scan.png', format='png', dpi=1000)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.5\n",
      "1.0\n",
      "1.5\n",
      "2.0\n",
      "2.5\n",
      "3.0\n",
      "3.5\n",
      "0.5\n",
      "1.0\n",
      "1.5\n",
      "2.0\n",
      "2.5\n",
      "3.0\n",
      "3.5\n",
      "0.5\n",
      "1.0\n",
      "1.5\n",
      "2.0\n",
      "2.5\n",
      "3.0\n",
      "3.5\n",
      "0.5\n",
      "1.0\n",
      "1.5\n",
      "2.0\n",
      "2.5\n",
      "3.0\n",
      "3.5\n",
      "0.5\n",
      "1.0\n",
      "1.5\n",
      "2.0\n",
      "2.5\n",
      "3.0\n",
      "3.5\n",
      "0.5\n",
      "1.0\n",
      "1.5\n",
      "2.0\n",
      "2.5\n",
      "3.0\n",
      "3.5\n",
      "0.5\n",
      "1.0\n",
      "1.5\n",
      "2.0\n",
      "2.5\n",
      "3.0\n",
      "3.5\n",
      "scan complete\n"
     ]
    }
   ],
   "source": [
    "'''\n",
    "x_travel_dist = 3\n",
    "y_travel_dist = 3\n",
    "gran = .5\n",
    "pitch = 1\n",
    "steps_per_rev = 1\n",
    "\n",
    "y_dist = 0\n",
    "x_dist = 0\n",
    "\n",
    "while y_dist <= (y_travel_dist):\n",
    "    if x_dist <= (x_travel_dist):\n",
    "        #move over right to next region to be scanned\n",
    "        move_x = (gran/pitch) * steps_per_rev #num of steps to take to move to next scanned region\n",
    "        x_dist += gran\n",
    "        print(x_dist)\n",
    "    else:\n",
    "        #move down a row\n",
    "        move_y = (gran/pitch) * steps_per_rev\n",
    "        y_dist += gran\n",
    "        x_dist = 0\n",
    "        \n",
    "        #move back to starting x position on left side\n",
    "        move_x = (x_travel_dist/pitch) * steps_per_rev\n",
    "        \n",
    "else:\n",
    "    print(\"scan complete\")\n",
    "'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
